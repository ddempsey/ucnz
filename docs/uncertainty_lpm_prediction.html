<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncertainty - LPM Prediction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { text-align: center; color: #333; }
        .explainer {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        .explainer p { margin: 1em 0; }
        .widget-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .control-group label { font-weight: 500; font-size: 13px; }
        .control-group input[type="range"] { width: 100px; }
        .canvas-container { display: flex; justify-content: center; }
        canvas { border: 1px solid #ddd; background: white; max-width: 100%; }
        .questions {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.8;
        }
        .questions p { margin: 0.8em 0; color: #555; }
    </style>
</head>
<body>
    <h1>LPM Prediction</h1>

    <div class="explainer">
        <p>
            Earlier, we estimated prior distributions for the model parameters, \(a\), \(b\), and
            \(c\). To make a prediction of the future, we need only sample each of those
            distributions and pass those parameter values into the model.
        </p>
        <p>
            As an exercise, we shall attempt to "predict" the pressure in the reservoir in 2012.
            This is something the folk back in 1981 may have tried to do when, say,
            reconsenting Wairakei for the next 30 years.
        </p>
        <p>
            Of course, since we actually have pressure measurements up to 2012, we'll be able to
            verify our forecast...
        </p>
        <p>
            Set prior widths from your analysis in the LPM Posterior exercise, then adjust samples
            and check the "reveal future" button to compare your forecast against the actual data.
        </p>
    </div>

    <div class="widget-container">
        <div class="controls">
            <div class="control-group">
                <label>\(\sigma_a\):</label>
                <input type="range" id="saSlider" min="0" max="10" step="1" value="3">
                <span id="saVal" style="min-width:55px; font-size:12px;">6.6e-5</span>
            </div>
            <div class="control-group">
                <label>\(\sigma_b\):</label>
                <input type="range" id="sbSlider" min="0" max="10" step="1" value="3">
                <span id="sbVal" style="min-width:55px; font-size:12px;">3.3e-3</span>
            </div>
            <div class="control-group">
                <label>\(\sigma_c\):</label>
                <input type="range" id="scSlider" min="0" max="10" step="1" value="4">
                <span id="scVal" style="min-width:55px; font-size:12px;">1.4e-3</span>
            </div>
            <div class="control-group">
                <label>samples:</label>
                <input type="range" id="nSlider" min="0" max="5" step="1" value="3">
                <span id="nVal">64</span>
            </div>
            <div class="control-group">
                <label><input type="checkbox" id="revealCheck"> reveal future!</label>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="950" height="380"></canvas>
        </div>
    </div>

    <div class="questions">
        <p>Use the slider bar to add more models. How does the shape and width of the forecast change?</p>
        <p>Click the "reveal future" button to compare your forecast against the actual data. How did you do?</p>
        <p>Speculate on any discrepancy between your forecast and the actual outcome.</p>
    </div>

    <script>
        // ========== PRNG ==========
        function mulberry32(a) {
            return function() {
                a |= 0; a = a + 0x6D2B79F5 | 0;
                var t = Math.imul(a ^ a >>> 15, 1 | a);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }
        function randn(rng) {
            let u1; do { u1 = rng(); } while (u1 === 0);
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * rng());
        }

        // ========== Full data (all 60 points) ==========
        const tqAll = [1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012];
        const qAll = [0,91.97,142.23,243.53,369.64,435.35,386.3,799.44,1001.33,853.13,1279.4,1680.92,1734.78,1651.72,1611.03,1473.87,1342.67,1486.49,1445.96,1440.69,1372.32,1305.38,1256.35,1246.42,1221.76,1465.79,1371.32,1293.33,1301.34,1291.3,1324.96,1285.62,1290.42,1186.84,1183.36,1199.62,1166.92,1133.06,1196.53,1082.51,1123.7,1129.39,1126.01,1123.67,1087.26,1117.1,1061.9,1001.17,890.8,919.24,989.27,1016.84,964.24,874.81,935.57,950.1,927.41,792.13,708.62,653.81];
        const tpAll = [1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012];
        const pAll = [56.26,55.69,55.5,54.73,52.76,52.15,51.48,47.71,46.87,45.55,41.84,38.51,36.28,35.1,34.16,34.42,33.56,33.03,32.5,32,31.7,31.64,31.73,31.69,31.83,31.02,30.7,30.84,30.32,30.56,30.26,30.29,30.1,30.49,30.73,30.4,31.07,30.5,30.16,30.17,29.93,29.95,29.87,29.93,30.05,30.05,30.91,31.53,32.14,32.34,32.46,31.95,32.3,33.13,33.12,33.15,33.08,33.77,33.78,33.17];

        // dq/dt for full data
        const N = tqAll.length;
        const dqdt = new Array(N).fill(0);
        dqdt[0] = (qAll[1] - qAll[0]) / (tqAll[1] - tqAll[0]);
        for (let i = 1; i < N - 1; i++) dqdt[i] = (qAll[i+1] - qAll[i-1]) / (tqAll[i+1] - tqAll[i-1]);
        dqdt[N-1] = (qAll[N-1] - qAll[N-2]) / (tqAll[N-1] - tqAll[N-2]);

        // 1981 cutoff index
        let ip1981 = 0;
        for (let i = 0; i < tpAll.length; i++) { if (Math.abs(tpAll[i] - 1981) < Math.abs(tpAll[ip1981] - 1981)) ip1981 = i; }
        ip1981++; // include 1981

        function interp(t, xs, ys) {
            if (t <= xs[0]) return ys[0];
            if (t >= xs[xs.length-1]) return ys[ys.length-1];
            for (let i = 0; i < xs.length-1; i++) {
                if (t >= xs[i] && t <= xs[i+1]) return ys[i] + (t - xs[i]) / (xs[i+1] - xs[i]) * (ys[i+1] - ys[i]);
            }
            return ys[ys.length-1];
        }

        function solveLPM(a, b, c) {
            const pm = [pAll[0]];
            for (let i = 0; i < tpAll.length - 1; i++) {
                const t0 = tpAll[i], t1 = tpAll[i+1], dt = t1 - t0;
                const pi1 = pm[i] - pAll[0];
                const dpdt1 = -a * interp(t0, tqAll, qAll) - b * pi1 - c * interp(t0, tqAll, dqdt);
                const pp = pm[i] + dpdt1 * dt;
                const dpdt2 = -a * interp(t1, tqAll, qAll) - b * (pp - pAll[0]) - c * interp(t1, tqAll, dqdt);
                pm.push(pm[i] + 0.5 * dt * (dpdt1 + dpdt2));
            }
            return pm;
        }

        const a0 = 2.2e-3, b0 = 1.1e-1, c0 = 6.8e-3;

        // ========== Canvas ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const cssW = 950, cssH = 380;
        canvas.width = cssW * dpr; canvas.height = cssH * dpr;
        canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
        ctx.scale(dpr, dpr);

        const PL = { x: 80, y: 30, w: 480, h: 300 };
        const PR = { x: 650, y: 30, w: 230, h: 300 };

        const tMin = 1952, tMax = 2013, pMin = 25, pMax = 60;
        function txL(t) { return PL.x + (t - tMin) / (tMax - tMin) * PL.w; }
        function tyL(v) { return PL.y + (pMax - v) / (pMax - pMin) * PL.h; }

        function draw() {
            const saIdx = parseInt(document.getElementById('saSlider').value);
            const sbIdx = parseInt(document.getElementById('sbSlider').value);
            const scIdx = parseInt(document.getElementById('scSlider').value);
            const nExp = parseInt(document.getElementById('nSlider').value);
            const Nmods = Math.pow(4, nExp);
            const reveal = document.getElementById('revealCheck').checked;

            const sa = saIdx * 2.2e-5;
            const sb = sbIdx * 1.1e-3;
            const sc = scIdx * 3.4e-4;

            document.getElementById('saVal').textContent = sa.toExponential(1);
            document.getElementById('sbVal').textContent = sb.toExponential(1);
            document.getElementById('scVal').textContent = sc.toExponential(1);
            document.getElementById('nVal').textContent = Nmods;

            const ip = reveal ? tpAll.length : ip1981;

            // Sample parameters
            const rng = mulberry32(13);
            const aVals = [], bVals = [], cVals = [];
            for (let i = 0; i < Nmods; i++) {
                aVals.push(randn(rng) * sa + a0);
                bVals.push(randn(rng) * sb + b0);
                cVals.push(randn(rng) * sc + c0);
            }

            ctx.clearRect(0, 0, cssW, cssH);

            // ===== Left panel =====
            ctx.save();
            ctx.beginPath(); ctx.rect(PL.x, PL.y, PL.w, PL.h); ctx.clip();

            // Observations + error bars
            const v = 2;
            for (let i = 0; i < ip; i++) {
                ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 0.5;
                ctx.beginPath(); ctx.moveTo(txL(tpAll[i]), tyL(pAll[i]-v)); ctx.lineTo(txL(tpAll[i]), tyL(pAll[i]+v)); ctx.stroke();
                ctx.fillStyle = '#FF0000';
                ctx.beginPath(); ctx.arc(txL(tpAll[i]), tyL(pAll[i]), 3, 0, 2*Math.PI); ctx.fill();
            }

            // Ensemble
            const alpha = Math.min(0.5, 10 / Nmods);
            const pmf = [];
            for (let k = 0; k < Nmods; k++) {
                const pm = solveLPM(aVals[k], bVals[k], cVals[k]);
                pmf.push(pm[pm.length - 1]);
                ctx.strokeStyle = `rgba(0,0,0,${alpha})`; ctx.lineWidth = 0.5;
                ctx.beginPath();
                for (let i = 0; i < tpAll.length; i++) {
                    if (i === 0) ctx.moveTo(txL(tpAll[i]), tyL(pm[i]));
                    else ctx.lineTo(txL(tpAll[i]), tyL(pm[i]));
                }
                ctx.stroke();
            }

            // Best model
            const pmBest = solveLPM(a0, b0, c0);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < tpAll.length; i++) {
                if (i === 0) ctx.moveTo(txL(tpAll[i]), tyL(pmBest[i]));
                else ctx.lineTo(txL(tpAll[i]), tyL(pmBest[i]));
            }
            ctx.stroke();

            // Predict future line
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
            ctx.beginPath(); ctx.moveTo(txL(tpAll[tpAll.length-1]), PL.y); ctx.lineTo(txL(tpAll[tpAll.length-1]), PL.y+PL.h); ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();

            // Left axes
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(PL.x, PL.y, PL.w, PL.h);
            ctx.fillStyle = '#000'; ctx.font = '13px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let t = 1960; t <= 2010; t += 10) {
                ctx.beginPath(); ctx.moveTo(txL(t), PL.y+PL.h); ctx.lineTo(txL(t), PL.y+PL.h+4); ctx.stroke();
                ctx.fillText(t.toString(), txL(t), PL.y+PL.h+6);
            }
            ctx.fillText('time [yr]', PL.x+PL.w/2, PL.y+PL.h+24);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            for (let p = 30; p <= 60; p += 10) {
                ctx.beginPath(); ctx.moveTo(PL.x-4, tyL(p)); ctx.lineTo(PL.x, tyL(p)); ctx.stroke();
                ctx.fillText(p.toString(), PL.x-6, tyL(p));
            }
            ctx.save(); ctx.translate(22, PL.y+PL.h/2); ctx.rotate(-Math.PI/2);
            ctx.font = '14px Segoe UI'; ctx.textAlign = 'center';
            ctx.fillText('pressure [bar]', 0, 0); ctx.restore();

            // Left legend (top right to avoid obscuring initial values)
            const lx = PL.x+PL.w-155, ly = PL.y+8;
            ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.fillRect(lx, ly, 145, 72); ctx.strokeRect(lx, ly, 145, 72);
            ctx.font = '12px Segoe UI'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            ctx.fillStyle = '#FF0000';
            ctx.beginPath(); ctx.arc(lx+10, ly+14, 3, 0, 2*Math.PI); ctx.fill();
            ctx.fillStyle = '#000'; ctx.fillText('observations', lx+22, ly+14);
            ctx.strokeStyle = `rgba(0,0,0,${Math.min(0.5,10/Nmods)})`; ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(lx+3, ly+34); ctx.lineTo(lx+17, ly+34); ctx.stroke();
            ctx.fillText('possible models', lx+22, ly+34);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(lx+3, ly+54); ctx.lineTo(lx+17, ly+54); ctx.stroke();
            ctx.fillText('best model', lx+22, ly+54);

            // ===== Right panel: forecast histogram =====
            const hMin = 30, hMax = 45, pyMin = 0, pyMax = 1;
            function txR(v) { return PR.x + (v - hMin) / (hMax - hMin) * PR.w; }
            function tyR(v) { return PR.y + (pyMax - v) / (pyMax - pyMin) * PR.h; }

            ctx.save();
            ctx.beginPath(); ctx.rect(PR.x, PR.y, PR.w, PR.h); ctx.clip();

            if (pmf.length > 0) {
                const minF = Math.min(...pmf) * 0.999, maxF = Math.max(...pmf) * 1.001;
                const nBins = Math.max(3, Math.floor(Math.sqrt(Nmods)));
                const binW = (maxF - minF) / nBins;
                const counts = new Array(nBins).fill(0);
                for (const v of pmf) {
                    const idx = Math.min(nBins-1, Math.floor((v - minF) / binW));
                    counts[idx]++;
                }
                const total = pmf.length * binW;
                for (let i = 0; i < nBins; i++) {
                    const h = counts[i] / total;
                    const bx = txR(minF + i * binW);
                    const bw = txR(minF + (i+1) * binW) - bx;
                    ctx.fillStyle = 'rgba(128,128,128,0.7)';
                    ctx.fillRect(bx, tyR(h), bw, tyR(0) - tyR(h));
                }

                if (Nmods > 10) {
                    // Best model line
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(txR(pmBest[pmBest.length-1]), PR.y); ctx.lineTo(txR(pmBest[pmBest.length-1]), PR.y+PR.h); ctx.stroke();

                    // 90% interval
                    const sorted = [...pmf].sort((a,b) => a-b);
                    const p5 = sorted[Math.floor(0.05 * sorted.length)];
                    const p95 = sorted[Math.floor(0.95 * sorted.length)];
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5; ctx.setLineDash([6,4]);
                    ctx.beginPath(); ctx.moveTo(txR(p5), PR.y); ctx.lineTo(txR(p5), PR.y+PR.h); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(txR(p95), PR.y); ctx.lineTo(txR(p95), PR.y+PR.h); ctx.stroke();
                    ctx.setLineDash([]);

                    if (reveal) {
                        const trueP = pAll[pAll.length - 1]; // 33.17
                        ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(txR(trueP), PR.y); ctx.lineTo(txR(trueP), PR.y+PR.h); ctx.stroke();
                        ctx.fillStyle = 'rgba(255,0,0,0.3)';
                        ctx.fillRect(txR(trueP - v), PR.y, txR(trueP + v) - txR(trueP - v), PR.h);
                    }
                }
            }
            ctx.restore();

            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(PR.x, PR.y, PR.w, PR.h);
            ctx.fillStyle = '#000'; ctx.font = '13px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let v = 30; v <= 45; v += 5) {
                ctx.beginPath(); ctx.moveTo(txR(v), PR.y+PR.h); ctx.lineTo(txR(v), PR.y+PR.h+4); ctx.stroke();
                ctx.fillText(v.toString(), txR(v), PR.y+PR.h+6);
            }
            ctx.fillText('pressure [bar]', PR.x+PR.w/2, PR.y+PR.h+24);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            for (let v = 0; v <= 1; v += 0.5) {
                ctx.beginPath(); ctx.moveTo(PR.x-4, tyR(v)); ctx.lineTo(PR.x, tyR(v)); ctx.stroke();
                ctx.fillText(v.toFixed(1), PR.x-6, tyR(v));
            }
            ctx.save(); ctx.translate(PR.x-28, PR.y+PR.h/2); ctx.rotate(-Math.PI/2);
            ctx.font = '14px Segoe UI'; ctx.textAlign = 'center';
            ctx.fillText('probability', 0, 0); ctx.restore();

            // Right legend
            if (Nmods > 10) {
                const lxR = PR.x+4, lyR = PR.y+4;
                const items = [['#000','-','best model']];
                items.push(['#000','--','90% interval']);
                if (reveal) items.push(['#FF0000','-','true process']);
                ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
                ctx.fillRect(lxR, lyR, 100, items.length * 18 + 8); ctx.strokeRect(lxR, lyR, 100, items.length * 18 + 8);
                ctx.font = '11px Segoe UI'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                for (let i = 0; i < items.length; i++) {
                    const iy = lyR + 10 + i * 18;
                    ctx.strokeStyle = items[i][0]; ctx.lineWidth = 1.5;
                    if (items[i][1] === '--') ctx.setLineDash([4,3]);
                    ctx.beginPath(); ctx.moveTo(lxR+4, iy); ctx.lineTo(lxR+20, iy); ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#000'; ctx.fillText(items[i][2], lxR+24, iy);
                }
            }
        }

        ['saSlider','sbSlider','scSlider','nSlider'].forEach(id =>
            document.getElementById(id).addEventListener('input', draw));
        document.getElementById('revealCheck').addEventListener('change', draw);
        draw();
    </script>
</body>
</html>
