<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibration - Parameter Space</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { text-align: center; color: #333; }
        .explainer {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        .explainer p { margin: 1em 0; }
        .widget-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label { font-weight: 500; }
        .control-group input[type="range"] { width: 200px; }
        .canvas-container { display: flex; justify-content: center; }
        canvas { border: 1px solid #ddd; background: white; max-width: 100%; }
        .questions {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.8;
        }
        .questions p { margin: 0.8em 0; color: #555; }
    </style>
</head>
<body>
    <h1>Parameter Space</h1>

    <div class="explainer">
        <p>
            We have expressed the input parameters to the model as a vector, \(\boldsymbol{\theta}\).
            Therefore, any particular choice of parameters (called a unique parameterisation of the model)
            corresponds to a point in \(N\)-dimensional space with a set of axes for each of the \(N\) parameters.
        </p>
        <p>
            Take, for example, the car with damped shock absorption and assume that we know precisely the values
            of \(m\) and \(g\). In this case, the unknown parameters to be chosen in order to calibrate the model
            are \(\boldsymbol{\theta}=[c,k]\). The allowed parameter combinations define a 2D plane in
            \(c\)-\(k\) parameter space with both the model prediction, \(f(x_i;\boldsymbol{\theta})\), and
            the objective function, \(S(\boldsymbol{\theta})\), surfaces over that space. In this geometric
            interpretation, model calibration is the process of searching through parameter space to find the
            value(s), \(\boldsymbol{\theta}_{min}\), that minimize \(S(\boldsymbol{\theta})\).
        </p>
        <p>
            As we saw in the previous section, <em>ad-hoc</em> calibration is a sort of "feeling your way around
            in the dark" approach to determining this minimum. We will now consider <em>gradient descent</em>, an
            automated, numerical approach to calibration. One way to conceptualize gradient descent is to consider
            the question "<em>if we placed a ball on the surface of the plot below and allowed it to roll, what
            path would it follow? Where would it come to rest?</em>"
        </p>
        <p><strong>Move the sliders and answer the questions below.</strong></p>
    </div>

    <div class="widget-container">
        <div class="controls">
            <div class="control-group">
                <label>\(c\):</label>
                <input type="range" id="cSlider" min="0" max="30" step="1" value="10">
            </div>
            <div class="control-group">
                <label>\(k\):</label>
                <input type="range" id="kSlider" min="4" max="25" step="1" value="10">
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="700" height="700"></canvas>
        </div>
    </div>

    <div class="questions">
        <p>Move the sliders \(c\) and \(k\). The orange surface spans the ALLOWED parameter combinations.</p>
        <p>What plane does the point \(\theta\) lie on?</p>
        <p>For each value of \(\theta\), there is a unique value \(S(\theta)\). True or False?</p>
        <p>For each value \(S(\theta)\), there is a unique value of \(\theta\). True or False?</p>
        <p>What is the goal of calibration, in terms of navigating the plotted surface?</p>
        <p>If \(S(\theta)\) is the objective function, what would you expect to change about the plot above if different weights were applied to certain observations?</p>
    </div>

    <script>
        // ========== Grid and surface ==========
        const N = 31;
        const zFloor = 7, zCeil = 13, zMid = 10, zRange = 6;

        function linspace(a, b, n) {
            const arr = [];
            for (let i = 0; i < n; i++) arr.push(a + i * (b - a) / (n - 1));
            return arr;
        }
        const xArr = linspace(0, 1, N);
        const yArr = linspace(0, 1, N);

        // Allowed region bounds
        let i1 = 0, i2 = 0, minD1 = 99, minD2 = 99;
        for (let i = 0; i < N; i++) {
            if (Math.abs(yArr[i] - 0.15) < minD1) { minD1 = Math.abs(yArr[i] - 0.15); i1 = i; }
            if (Math.abs(yArr[i] - 0.85) < minD2) { minD2 = Math.abs(yArr[i] - 0.85); i2 = i; }
        }

        // Surface function parameters
        const xm = 0.4, ym = 0.6, sx = 0.06, sy = 0.12;
        const par = [10, 4, 2, xm, ym, sx, sy];

        function rFunc(x, y) {
            return (par[0] - Math.exp(-((x - par[3]) ** 2 / par[5] + (y - par[4]) ** 2 / par[6]))) *
                (1 - (x / par[1]) ** par[2]) * (1 + (y / par[1]) ** par[2]);
        }

        // Pre-compute grid
        const zGrid = [];
        let zSurfMin = Infinity, zSurfMax = -Infinity;
        for (let j = 0; j < N; j++) {
            zGrid[j] = [];
            for (let i = 0; i < N; i++) {
                zGrid[j][i] = rFunc(xArr[i], yArr[j]);
                if (j >= i1 && j <= i2) {
                    zSurfMin = Math.min(zSurfMin, zGrid[j][i]);
                    zSurfMax = Math.max(zSurfMax, zGrid[j][i]);
                }
            }
        }

        // ========== 3D Projection ==========
        const az = -60 * Math.PI / 180, el = 30 * Math.PI / 180;
        const cosA = Math.cos(az), sinA = Math.sin(az);
        const cosE = Math.cos(el), sinE = Math.sin(el);

        function project(x, y, z) {
            const cx = x - 0.5, cy = y - 0.5, cz = (z - zMid) / zRange;
            return {
                sx: -sinA * cx + cosA * cy,
                sy: -cosA * sinE * cx - sinA * sinE * cy + cosE * cz,
                depth: cosA * cosE * cx + sinA * cosE * cy + sinE * cz
            };
        }

        // ========== Canvas ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const cssW = 700, cssH = 700;
        canvas.width = cssW * dpr;
        canvas.height = cssH * dpr;
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        ctx.scale(dpr, dpr);

        const centerX = 350, centerY = 330, scale = 370;

        function toCanvas(p) {
            return { x: centerX + p.sx * scale, y: centerY - p.sy * scale };
        }

        // ========== Oranges colormap ==========
        function orangeColor(t) {
            t = Math.max(0, Math.min(1, t));
            const stops = [
                [0.0, 255, 245, 235], [0.25, 254, 216, 170],
                [0.5, 253, 174, 107], [0.75, 241, 105, 19], [1.0, 166, 54, 3]
            ];
            for (let i = 0; i < stops.length - 1; i++) {
                if (t <= stops[i + 1][0]) {
                    const f = (t - stops[i][0]) / (stops[i + 1][0] - stops[i][0]);
                    return `rgb(${Math.round(stops[i][1] + f * (stops[i + 1][1] - stops[i][1]))},${Math.round(stops[i][2] + f * (stops[i + 1][2] - stops[i][2]))},${Math.round(stops[i][3] + f * (stops[i + 1][3] - stops[i][3]))})`;
                }
            }
            return 'rgb(166,54,3)';
        }

        // ========== Pre-compute quads (static surface) ==========
        const allQuads = [];
        for (let j = 0; j < N - 1; j++) {
            for (let i = 0; i < N - 1; i++) {
                const corners3D = [
                    [xArr[i], yArr[j], zGrid[j][i]],
                    [xArr[i + 1], yArr[j], zGrid[j][i + 1]],
                    [xArr[i + 1], yArr[j + 1], zGrid[j + 1][i + 1]],
                    [xArr[i], yArr[j + 1], zGrid[j + 1][i]]
                ];
                const projected = corners3D.map(c => project(c[0], c[1], c[2]));
                const avgDepth = projected.reduce((s, p) => s + p.depth, 0) / 4;
                const avgZ = corners3D.reduce((s, c) => s + c[2], 0) / 4;
                const filled = j >= i1 && j < i2;
                allQuads.push({ projected, avgDepth, filled, colorT: (avgZ - zSurfMin) / (zSurfMax - zSurfMin) });
            }
        }
        // Sort once (surface is static)
        allQuads.sort((a, b) => a.avgDepth - b.avgDepth);

        // ========== Drawing ==========
        function draw() {
            const ic = parseInt(document.getElementById('cSlider').value);
            const ik = parseInt(document.getElementById('kSlider').value);
            ctx.clearRect(0, 0, cssW, cssH);

            const xi = xArr[ic], yi = yArr[ik];
            const zi = rFunc(xi, yi);

            // Draw surface quads (back to front)
            for (const q of allQuads) {
                const sc = q.projected.map(p => toCanvas(p));
                ctx.beginPath();
                ctx.moveTo(sc[0].x, sc[0].y);
                for (let k = 1; k < 4; k++) ctx.lineTo(sc[k].x, sc[k].y);
                ctx.closePath();
                if (q.filled) {
                    ctx.fillStyle = orangeColor(q.colorT);
                    ctx.fill();
                }
                ctx.strokeStyle = 'rgba(0,0,0,0.35)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }

            // Floor boundary lines (dotted)
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            let p1 = toCanvas(project(0, yArr[i1], zFloor));
            let p2 = toCanvas(project(1, yArr[i1], zFloor));
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            p1 = toCanvas(project(0.72, yArr[i2], zFloor));
            p2 = toCanvas(project(1, yArr[i2], zFloor));
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            ctx.setLineDash([]);

            // Projection lines from theta
            const pSurf = toCanvas(project(xi, yi, zi));
            const pFloor = toCanvas(project(xi, yi, zFloor));
            const pYEdge = toCanvas(project(xi, yArr[0], zFloor));
            const pXEdge = toCanvas(project(xArr[N - 1], yi, zFloor));

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(pSurf.x, pSurf.y);
            ctx.lineTo(pFloor.x, pFloor.y);
            ctx.lineTo(pYEdge.x, pYEdge.y);
            ctx.moveTo(pFloor.x, pFloor.y);
            ctx.lineTo(pXEdge.x, pXEdge.y);
            ctx.stroke();

            // Floor point marker (white-filled square)
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.fillRect(pFloor.x - 5, pFloor.y - 5, 10, 10);
            ctx.strokeRect(pFloor.x - 5, pFloor.y - 5, 10, 10);

            // Floor label: theta
            ctx.fillStyle = '#000';
            ctx.font = '16px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('\u03B8', pFloor.x, pFloor.y + 10);

            // Surface point marker (X)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2.5;
            const ms = 7;
            ctx.beginPath();
            ctx.moveTo(pSurf.x - ms, pSurf.y - ms);
            ctx.lineTo(pSurf.x + ms, pSurf.y + ms);
            ctx.moveTo(pSurf.x + ms, pSurf.y - ms);
            ctx.lineTo(pSurf.x - ms, pSurf.y + ms);
            ctx.stroke();

            // Surface label: S(theta)
            ctx.fillStyle = '#000';
            ctx.font = '16px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            // White background behind text
            const label = 'S(\u03B8)';
            const tw = ctx.measureText(label).width;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(pSurf.x - tw / 2 - 3, pSurf.y - 28, tw + 6, 20);
            ctx.fillStyle = '#000';
            ctx.fillText(label, pSurf.x, pSurf.y - 10);

            // Axis labels
            drawAxisLabels();
        }

        function drawAxisLabels() {
            // x-axis (c): along bottom edge at y=0, z=zFloor
            const xMidA = toCanvas(project(0.5, 0, zFloor));
            const xEndA = toCanvas(project(1, 0, zFloor));
            ctx.fillStyle = '#000';
            ctx.font = 'italic 18px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('c', xMidA.x, xMidA.y + 12);

            // y-axis (k): along bottom edge at x=1, z=zFloor
            const yMidA = toCanvas(project(1, 0.5, zFloor));
            ctx.textBaseline = 'top';
            ctx.fillText('k', yMidA.x + 15, yMidA.y + 5);

            // z-axis: vertical at front corner
            const zMidA = toCanvas(project(1, 0, zMid));
            ctx.save();
            ctx.translate(zMidA.x + 18, zMidA.y);
            ctx.font = 'italic 18px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('S(\u03B8)', 0, 0);
            ctx.restore();

            // Draw axis lines (edges of the bounding box)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;

            // Bottom edges
            const corners = [
                toCanvas(project(0, 0, zFloor)),
                toCanvas(project(1, 0, zFloor)),
                toCanvas(project(1, 1, zFloor)),
                toCanvas(project(0, 1, zFloor))
            ];
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            for (let i = 1; i <= 3; i++) ctx.lineTo(corners[i].x, corners[i].y);
            ctx.closePath();
            ctx.stroke();

            // Vertical edge at front
            const topFront = toCanvas(project(1, 0, zCeil));
            ctx.beginPath();
            ctx.moveTo(corners[1].x, corners[1].y);
            ctx.lineTo(topFront.x, topFront.y);
            ctx.stroke();
        }

        // ========== Events ==========
        document.getElementById('cSlider').addEventListener('input', draw);
        document.getElementById('kSlider').addEventListener('input', draw);
        draw();
    </script>
</body>
</html>
