<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibration - Gradient Descent</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { text-align: center; color: #333; }
        .explainer {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        .explainer p { margin: 1em 0; }
        .widget-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .path-controls {
            display: flex;
            gap: 25px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .path-label {
            font-weight: 600;
            font-size: 13px;
            min-width: 50px;
            padding: 2px 8px;
            border-radius: 3px;
            color: white;
        }
        .path-label-1 { background: #c0392b; }
        .path-label-2 { background: #27ae60; }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label { font-weight: 500; font-size: 13px; }
        .control-group input[type="range"] { width: 140px; }
        .control-group .value {
            min-width: 35px;
            text-align: right;
            font-family: monospace;
            font-size: 13px;
        }
        .canvas-container { display: flex; justify-content: center; }
        canvas { border: 1px solid #ddd; background: white; max-width: 100%; }
        .questions {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.8;
        }
        .questions p { margin: 0.8em 0; color: #555; }
    </style>
</head>
<body>
    <h1>Gradient Descent</h1>

    <div class="explainer">
        <p>
            Returning now to the question "<em>if we placed a ball on the objective function surface and allowed it to roll, what path would it follow?</em>" We understand intuitively that the ball would initially accelerate in the direction of the steepest descent, i.e., \(-\hat{\mathbf{s}}'\). Furthermore, if the ball continued to follow the path of steepest descent then it should eventually end up at the minimum. This concept serves as the basis for <strong>gradient descent</strong> (also called the <em>method of steepest descent</em>). The steps are:
        </p>
        <ol>
            <li>Choose \(\boldsymbol{\theta}_0\), an initial guess of the parameter set that minimizes the objective function, \(\boldsymbol{\theta}_{min}\).</li>
            <li>Compute the direction of steepest descent at \(\boldsymbol{\theta}_0\), i.e., \(-\hat{\mathbf{s}}'(\boldsymbol{\theta}_0)\).</li>
            <li>Update the estimate of \(\boldsymbol{\theta}_{min}\) by incrementing in the direction of steepest descent, i.e., \(\boldsymbol{\theta}_1=\boldsymbol{\theta}_0-\alpha\,\hat{\mathbf{s}}'(\boldsymbol{\theta}_0)\).</li>
            <li>Repeat steps 2 and 3 to improve the estimate of \(\boldsymbol{\theta}_{min}\), i.e.,
                <p style="text-align:center;">
                    \[\boldsymbol{\theta}_{i+1} = \boldsymbol{\theta}_i - \alpha\,\hat{\mathbf{s}}'(\boldsymbol{\theta}_i)\]
                </p>
                Providing the step size \(\alpha\) is small enough, this algorithm will satisfy \(S(\boldsymbol{\theta}_{i+1}) < S(\boldsymbol{\theta}_i)\), i.e., each update is a better estimate (the residual is smaller) than the previous.
            </li>
        </ol>
        <p><strong>Use the sliders to explore gradient descent. Two paths can be compared simultaneously.</strong></p>
    </div>

    <div class="widget-container">
        <div class="path-controls">
            <span class="path-label path-label-1">Path 1</span>
            <div class="control-group">
                <label>\(c_1\):</label>
                <input type="range" id="c1Slider" min="0" max="20" step="1" value="15">
            </div>
            <div class="control-group">
                <label>\(k_1\):</label>
                <input type="range" id="k1Slider" min="3" max="17" step="1" value="13">
            </div>
            <div class="control-group">
                <label>steps:</label>
                <input type="range" id="n1Slider" min="0" max="30" step="1" value="0">
                <span class="value" id="n1Value">0</span>
            </div>
            <div class="control-group">
                <label>\(\alpha\):</label>
                <input type="range" id="a1Slider" min="0" max="0.10" step="0.02" value="0.04">
                <span class="value" id="a1Value">0.04</span>
            </div>
        </div>
        <div class="path-controls">
            <span class="path-label path-label-2">Path 2</span>
            <div class="control-group">
                <label>\(c_2\):</label>
                <input type="range" id="c2Slider" min="0" max="20" step="1" value="16">
            </div>
            <div class="control-group">
                <label>\(k_2\):</label>
                <input type="range" id="k2Slider" min="3" max="17" step="1" value="13">
            </div>
            <div class="control-group">
                <label>steps:</label>
                <input type="range" id="n2Slider" min="0" max="30" step="1" value="0">
                <span class="value" id="n2Value">0</span>
            </div>
            <div class="control-group">
                <label>\(\alpha\):</label>
                <input type="range" id="a2Slider" min="0" max="0.10" step="0.02" value="0.04">
                <span class="value" id="a2Value">0.04</span>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="650" height="650"></canvas>
        </div>
    </div>

    <div class="questions">
        <p>Set both paths to start at \(c = 0.75\), \(k = 1.3\). Increase the steps. Describe the trajectory.</p>
        <p>Increase \(\alpha\) for Path 1 only. Will it take MORE or LESS computation to find the minimum? Are there any disadvantages?</p>
        <p>Now set Path 1 to \(c = 0.75\), \(k = 1.3\) and Path 2 to \(c = 0.8\), \(k = 1.3\). Increase steps for both. Do both paths arrive at the same minimum?</p>
    </div>

    <script>
        // ========== Surface function ==========
        const par = [10, 4, 2, 0.4, 0.6, 0.06, 0.12];
        function rFunc(x, y) {
            return (par[0] - Math.exp(-((x-par[3])**2/par[5] + (y-par[4])**2/par[6]))) *
                (1 - (x/par[1])**par[2]) * (1 + (y/par[1])**par[2]);
        }

        function linspace(a, b, n) {
            const arr = [];
            for (let i = 0; i < n; i++) arr.push(a + i * (b - a) / (n - 1));
            return arr;
        }

        // ========== Pre-compute grid ==========
        const NG = 101;
        const xG = linspace(0, 1, NG);
        const yG = linspace(0, 1, NG);
        const zG = [];
        let zMin = Infinity, zMax = -Infinity;
        for (let j = 0; j < NG; j++) {
            zG[j] = [];
            for (let i = 0; i < NG; i++) {
                zG[j][i] = rFunc(xG[i], yG[j]);
                if (zG[j][i] < zMin) zMin = zG[j][i];
                if (zG[j][i] > zMax) zMax = zG[j][i];
            }
        }
        const levels = linspace(zMin, zMax, 11);

        // Allowed region
        let i1 = 0, i2 = 0, md1 = 99, md2 = 99;
        for (let i = 0; i < NG; i++) {
            if (Math.abs(yG[i] - 0.15) < md1) { md1 = Math.abs(yG[i] - 0.15); i1 = i; }
            if (Math.abs(yG[i] - 0.85) < md2) { md2 = Math.abs(yG[i] - 0.85); i2 = i; }
        }

        // ========== Canvas ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const cssW = 650, cssH = 650;
        canvas.width = cssW * dpr;
        canvas.height = cssH * dpr;
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        ctx.scale(dpr, dpr);

        const margin = { top: 20, right: 25, bottom: 60, left: 70 };
        const plotW = cssW - margin.left - margin.right;
        const plotH = cssH - margin.top - margin.bottom;
        function txf(x) { return margin.left + x * plotW; }
        function tyf(y) { return margin.top + (1 - y) * plotH; }

        // ========== Oranges colormap ==========
        function orangeColor(t) {
            t = Math.max(0, Math.min(1, t));
            const S = [
                [0, 255, 245, 235],
                [0.25, 253, 208, 162],
                [0.5, 253, 141, 60],
                [0.75, 230, 85, 13],
                [1, 127, 39, 4]
            ];
            for (let i = 0; i < S.length - 1; i++) {
                if (t <= S[i+1][0]) {
                    const f = (t - S[i][0]) / (S[i+1][0] - S[i][0]);
                    return `rgb(${Math.round(S[i][1]+f*(S[i+1][1]-S[i][1]))},${Math.round(S[i][2]+f*(S[i+1][2]-S[i][2]))},${Math.round(S[i][3]+f*(S[i+1][3]-S[i][3]))})`;
                }
            }
            return 'rgb(127,39,4)';
        }

        function getLevelBand(z) {
            for (let k = 0; k < levels.length - 1; k++) {
                if (z <= levels[k + 1]) return k;
            }
            return levels.length - 2;
        }

        // ========== Marching squares ==========
        const MS_TABLE = [
            [],[[3,0]],[[0,1]],[[3,1]],[[1,2]],[[3,0],[1,2]],[[0,2]],[[3,2]],
            [[2,3]],[[0,2]],[[0,3],[2,1]],[[1,2]],[[1,3]],[[0,1]],[[0,3]],[]
        ];

        function edgePt(edge, x0, y0, x1, y1, z0, z1, z2, z3, lv) {
            switch(edge) {
                case 0: { const t=(lv-z0)/(z1-z0); return [x0+t*(x1-x0), y0]; }
                case 1: { const t=(lv-z1)/(z2-z1); return [x1, y0+t*(y1-y0)]; }
                case 2: { const t=(lv-z2)/(z3-z2); return [x1+t*(x0-x1), y1]; }
                case 3: { const t=(lv-z3)/(z0-z3); return [x0, y1+t*(y0-y1)]; }
            }
        }

        // ========== Pre-render background ==========
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = cssW * dpr;
        bgCanvas.height = cssH * dpr;
        const bgCtx = bgCanvas.getContext('2d');
        bgCtx.scale(dpr, dpr);

        (function renderBackground() {
            bgCtx.clearRect(0, 0, cssW, cssH);
            const cellW = plotW / (NG - 1);
            const cellH = plotH / (NG - 1);

            // Filled contours (allowed region)
            for (let j = i1; j < i2; j++) {
                for (let i = 0; i < NG - 1; i++) {
                    const avgZ = (zG[j][i] + zG[j][i+1] + zG[j+1][i+1] + zG[j+1][i]) / 4;
                    const band = getLevelBand(avgZ);
                    bgCtx.fillStyle = orangeColor((band + 0.5) / (levels.length - 1));
                    bgCtx.fillRect(txf(xG[i]), tyf(yG[j+1]), cellW + 0.5, cellH + 0.5);
                }
            }

            // Contour lines (full domain)
            bgCtx.strokeStyle = 'rgba(0,0,0,0.5)';
            bgCtx.lineWidth = 1;
            for (let lIdx = 0; lIdx < levels.length; lIdx++) {
                const lv = levels[lIdx];
                bgCtx.beginPath();
                for (let j = 0; j < NG - 1; j++) {
                    for (let i = 0; i < NG - 1; i++) {
                        const z0 = zG[j][i], z1 = zG[j][i+1];
                        const z2 = zG[j+1][i+1], z3 = zG[j+1][i];
                        const idx = (z0>=lv?1:0)+(z1>=lv?2:0)+(z2>=lv?4:0)+(z3>=lv?8:0);
                        if (idx === 0 || idx === 15) continue;
                        const segs = MS_TABLE[idx];
                        const x0 = xG[i], x1 = xG[i+1], y0 = yG[j], y1 = yG[j+1];
                        for (const [e1, e2] of segs) {
                            const p1 = edgePt(e1, x0, y0, x1, y1, z0, z1, z2, z3, lv);
                            const p2 = edgePt(e2, x0, y0, x1, y1, z0, z1, z2, z3, lv);
                            bgCtx.moveTo(txf(p1[0]), tyf(p1[1]));
                            bgCtx.lineTo(txf(p2[0]), tyf(p2[1]));
                        }
                    }
                }
                bgCtx.stroke();
            }
        })();

        // ========== Drawing ==========
        function drawArrow(cx, x1, y1, x2, y2, hl, hw) {
            const dx = x2 - x1, dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 1e-6) return;
            const ux = dx/len, uy = dy/len;
            cx.beginPath();
            cx.moveTo(x1, y1);
            cx.lineTo(x2 - ux*hl, y2 - uy*hl);
            cx.stroke();
            cx.beginPath();
            cx.moveTo(x2, y2);
            cx.lineTo(x2 - ux*hl - uy*hw/2, y2 - uy*hl + ux*hw/2);
            cx.lineTo(x2 - ux*hl + uy*hw/2, y2 - uy*hl - ux*hw/2);
            cx.closePath();
            cx.fill();
        }

        function drawPath(ic, ik, N, alpha, color) {
            let xi = ic / 20;
            let yi = ik / 20;
            const startPx = txf(xi), startPy = tyf(yi);

            // Dotted projection lines from start
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            ctx.moveTo(txf(0), startPy);
            ctx.lineTo(startPx, startPy);
            ctx.lineTo(startPx, tyf(0));
            ctx.stroke();
            ctx.setLineDash([]);

            // Starting X marker
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;
            const ms = 8;
            ctx.beginPath();
            ctx.moveTo(startPx - ms, startPy - ms); ctx.lineTo(startPx + ms, startPy + ms);
            ctx.moveTo(startPx + ms, startPy - ms); ctx.lineTo(startPx - ms, startPy + ms);
            ctx.stroke();

            // Gradient descent steps
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 1.8;
            for (let step = 0; step < N; step++) {
                const dx = 0.01;
                const zi = rFunc(xi, yi);
                const dSdx = (rFunc(xi + dx, yi) - zi) / dx;
                const dSdy = (rFunc(xi, yi + dx) - zi) / dx;
                const mag = Math.sqrt(dSdx*dSdx + dSdy*dSdy);
                if (mag < 1e-10) break;
                const sx = -dSdx / mag;
                const sy = -dSdy / mag;
                const xi1 = xi + alpha * sx;
                const yi1 = yi + alpha * sy;

                drawArrow(ctx, txf(xi), tyf(yi), txf(xi1), tyf(yi1), 7, 7);

                xi = xi1;
                yi = yi1;
            }
        }

        function draw() {
            const ic1 = parseInt(document.getElementById('c1Slider').value);
            const ik1 = parseInt(document.getElementById('k1Slider').value);
            const N1 = parseInt(document.getElementById('n1Slider').value);
            const a1 = parseFloat(document.getElementById('a1Slider').value);
            const ic2 = parseInt(document.getElementById('c2Slider').value);
            const ik2 = parseInt(document.getElementById('k2Slider').value);
            const N2 = parseInt(document.getElementById('n2Slider').value);
            const a2 = parseFloat(document.getElementById('a2Slider').value);

            document.getElementById('n1Value').textContent = N1;
            document.getElementById('a1Value').textContent = a1.toFixed(2);
            document.getElementById('n2Value').textContent = N2;
            document.getElementById('a2Value').textContent = a2.toFixed(2);

            // Copy background
            ctx.clearRect(0, 0, cssW, cssH);
            ctx.drawImage(bgCanvas, 0, 0, cssW * dpr, cssH * dpr, 0, 0, cssW, cssH);

            // Draw both paths
            drawPath(ic1, ik1, N1, a1, '#c0392b');
            drawPath(ic2, ik2, N2, a2, '#27ae60');

            // Axes border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(margin.left, margin.top, plotW, plotH);

            // Axis labels
            ctx.font = 'italic 16px Segoe UI';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('c', margin.left + plotW / 2, cssH - 20);
            ctx.save();
            ctx.translate(18, margin.top + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('k', 0, 0);
            ctx.restore();

            // Axis tick labels
            ctx.font = '14px Segoe UI';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('0', txf(0), margin.top + plotH + 8);
            ctx.fillText('1', txf(1), margin.top + plotH + 8);
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('0', margin.left - 10, tyf(0));
            ctx.fillText('1', margin.left - 10, tyf(1));

            // Starting point labels
            ctx.font = '13px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const x1 = ic1/20, y1 = ik1/20;
            const x2 = ic2/20, y2 = ik2/20;

            // Path 1 tick
            ctx.fillStyle = '#c0392b';
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 1;
            const px1 = txf(x1);
            ctx.beginPath(); ctx.moveTo(px1, margin.top + plotH); ctx.lineTo(px1, margin.top + plotH + 5); ctx.stroke();
            ctx.fillText(x1.toFixed(2), px1, margin.top + plotH + 7);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            const py1 = tyf(y1);
            ctx.beginPath(); ctx.moveTo(margin.left - 5, py1); ctx.lineTo(margin.left, py1); ctx.stroke();
            ctx.fillText((y1*2).toFixed(1), margin.left - 8, py1);

            // Path 2 tick
            ctx.fillStyle = '#27ae60';
            ctx.strokeStyle = '#27ae60';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const px2 = txf(x2);
            ctx.beginPath(); ctx.moveTo(px2, margin.top + plotH); ctx.lineTo(px2, margin.top + plotH + 5); ctx.stroke();
            ctx.fillText(x2.toFixed(2), px2, margin.top + plotH + 20);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            const py2 = tyf(y2);
            ctx.beginPath(); ctx.moveTo(margin.left - 5, py2); ctx.lineTo(margin.left, py2); ctx.stroke();
            ctx.fillText((y2*2).toFixed(1), margin.left - 8, py2);
        }

        ['c1Slider','k1Slider','n1Slider','a1Slider',
         'c2Slider','k2Slider','n2Slider','a2Slider'].forEach(id =>
            document.getElementById(id).addEventListener('input', draw));
        draw();
    </script>
</body>
</html>
