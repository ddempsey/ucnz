<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncertainty - Posterior Distribution</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { text-align: center; color: #333; }
        .explainer {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        .explainer p { margin: 1em 0; }
        .widget-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label { font-weight: 500; }
        .control-group input[type="range"] { width: 200px; }
        .canvas-container { display: flex; justify-content: center; }
        canvas { border: 1px solid #ddd; background: white; max-width: 100%; }
        .questions {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.8;
        }
        .questions p { margin: 0.8em 0; color: #555; }
    </style>
</head>
<body>
    <h1>Posterior Distribution</h1>

    <div class="explainer">
        <p>
            The human scientists have satisfied themselves that the physical process is
            probably linear in nature and, therefore, a model of the form \(y_i = mx_i + c\) will
            provide a suitable fit to the data. Using gradient descent calibration, they quickly
            determine that the best-fitting model has \(m = 2.2\) and \(c = 3.1\), i.e.,
            \(\hat{\boldsymbol{\theta}}_0 = [2.2, 3.1]\). Clearly, this is different to the true value,
            \(\boldsymbol{\theta}_0 = [2.0, 3.0]\), but that was expected.
        </p>
        <p>
            To gain a more in-depth understanding of possible candidate models, a grid search is
            undertaken to compute \(S(\boldsymbol{\theta})\) and then the <strong>posterior</strong>
            distribution, \(P(\boldsymbol{\theta}|\tilde{y}_i) = A\,e^{-S(\boldsymbol{\theta})/2}\).
            The posterior makes two important points:
        </p>
        <ol style="line-height:1.8;">
            <li>We don't currently know &mdash; in fact we will never know &mdash; the true parameter,
                \(\boldsymbol{\theta}_0\). Even our best guess, the least-squares fit,
                \(\hat{\boldsymbol{\theta}}_0\), will be wrong to some degree.</li>
            <li>Nevertheless, we can determine which parameter combinations are consistent with
                the data, and rank their likelihood relative to each other.</li>
        </ol>
        <p>
            Given these caveats, it is comforting to see that the true value,
            \(\boldsymbol{\theta}_0\), is near enough to the centre of mass of
            \(P(\boldsymbol{\theta}|\tilde{y}_i)\) that it is among the likely candidates.
        </p>
        <p><strong>Move the sliders and answer the questions below.</strong></p>
    </div>

    <div class="widget-container">
        <div class="controls">
            <div class="control-group">
                <label>\(m\):</label>
                <input type="range" id="mSlider" min="0" max="40" step="1" value="20">
                <span id="mVal">2.10</span>
            </div>
            <div class="control-group">
                <label>\(c\):</label>
                <input type="range" id="cSlider" min="0" max="40" step="1" value="20">
                <span id="cVal">3.05</span>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="920" height="430"></canvas>
        </div>
    </div>

    <div class="questions">
        <p>The righthand figure is computed by a grid search over \(c\)-\(m\) parameter space.</p>
        <p>Use the sliders to fit different models (left) and explore parameter space (right).</p>
        <p>The best-fit model is not the same as the true process. Why?</p>
        <p>Does the best-fit model or the true process correspond to the higher value on the righthand plot?</p>
        <p>The righthand inset shows the posterior as a surface. The shape is 2D Gaussian.</p>
        <p>If we were to fit major and minor axes to the posterior, would they align with the \(c\)- and \(m\)- axes?</p>
    </div>

    <script>
        // ========== Model & data ==========
        const m0 = 2, c0 = 3, variance = 0.1;
        const Nm = 41, Nc = 41;
        const mmin = 1.3, mmax = 2.9, cmin = 2.55, cmax = 3.55;

        // Observations from Python numpy (seed=13, m=2, c=3, var=0.1)
        const xo = [0.090909090909091, 0.181818181818182, 0.272727272727273, 0.363636363636364, 0.454545454545455, 0.545454545454545, 0.636363636363636, 0.727272727272727, 0.818181818181818, 0.909090909090909];
        const yo = [2.956540474226668, 3.601998221658524, 3.531381436410830, 3.870148333813151, 4.334449417419804, 4.259249112090596, 4.699694175959493, 4.726884403467310, 5.103965123753951, 4.487604543546525];

        // Least squares best fit
        function lsq(x, y) {
            const n = x.length;
            let sx = 0, sy = 0, sxx = 0, sxy = 0;
            for (let i = 0; i < n; i++) { sx += x[i]; sy += y[i]; sxx += x[i]*x[i]; sxy += x[i]*y[i]; }
            const d = n * sxx - sx * sx;
            return [(n * sxy - sx * sy) / d, (sy * sxx - sx * sxy) / d];
        }
        const [mf, cf] = lsq(xo, yo);

        // ========== Grid search ==========
        function linspace(a, b, n) { const r = []; for (let i = 0; i < n; i++) r.push(a + i * (b - a) / (n - 1)); return r; }
        const mArr = linspace(mmin, mmax, Nm);
        const cArr = linspace(cmin, cmax, Nc);
        const dm = mArr[1] - mArr[0], dc = cArr[1] - cArr[0];

        const P = [];
        let maxP = 0;
        for (let j = 0; j < Nc; j++) {
            P[j] = [];
            for (let i = 0; i < Nm; i++) {
                let S = 0;
                for (let k = 0; k < 10; k++) {
                    const resid = yo[k] - (mArr[i] * xo[k] + cArr[j]);
                    S += resid * resid / variance;
                }
                P[j][i] = Math.exp(-S / 2);
            }
        }
        // Normalize
        let sumP = 0;
        for (let j = 0; j < Nc; j++) for (let i = 0; i < Nm; i++) sumP += P[j][i];
        sumP *= dm * dc;
        for (let j = 0; j < Nc; j++) for (let i = 0; i < Nm; i++) { P[j][i] /= sumP; maxP = Math.max(maxP, P[j][i]); }

        // ========== Jet colormap ==========
        function jetRGB(t) {
            t = Math.max(0, Math.min(1, t));
            let r, g, b;
            if (t < 0.125)      { r = 0;   g = 0;   b = 0.5 + t / 0.125 * 0.5; }
            else if (t < 0.375) { r = 0;   g = (t - 0.125) / 0.25; b = 1; }
            else if (t < 0.625) { r = (t - 0.375) / 0.25; g = 1;   b = 1 - (t - 0.375) / 0.25; }
            else if (t < 0.875) { r = 1;   g = 1 - (t - 0.625) / 0.25; b = 0; }
            else                { r = 1 - (t - 0.875) / 0.125 * 0.5; g = 0; b = 0; }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // ========== Pre-render heatmap ==========
        const hmCanvas = document.createElement('canvas');
        hmCanvas.width = Nm; hmCanvas.height = Nc;
        const hmCtx = hmCanvas.getContext('2d');
        const hmData = hmCtx.createImageData(Nm, Nc);
        for (let j = 0; j < Nc; j++) {
            for (let i = 0; i < Nm; i++) {
                const t = P[j][i] / maxP;
                const [r, g, b] = jetRGB(t);
                const idx = ((Nc - 1 - j) * Nm + i) * 4;
                hmData.data[idx] = r; hmData.data[idx+1] = g; hmData.data[idx+2] = b; hmData.data[idx+3] = 255;
            }
        }
        hmCtx.putImageData(hmData, 0, 0);

        // ========== Pre-render 3D surface ==========
        const az3 = -60 * Math.PI / 180, el3 = 30 * Math.PI / 180;
        const cosA3 = Math.cos(az3), sinA3 = Math.sin(az3);
        const cosE3 = Math.cos(el3), sinE3 = Math.sin(el3);

        function proj3(x, y, z) {
            const cx = x - 0.5, cy = y - 0.5;
            return {
                sx: -sinA3 * cx + cosA3 * cy,
                sy: -cosA3 * sinE3 * cx - sinA3 * sinE3 * cy + cosE3 * z,
                depth: cosA3 * cosE3 * cx + sinA3 * cosE3 * cy + sinE3 * z
            };
        }

        const step3 = 2; // subsample for 3D
        const n3m = Math.floor((Nm - 1) / step3);
        const n3c = Math.floor((Nc - 1) / step3);
        const quads3D = [];
        for (let jj = 0; jj < n3c; jj++) {
            for (let ii = 0; ii < n3m; ii++) {
                const j0 = jj * step3, j1 = (jj + 1) * step3;
                const i0 = ii * step3, i1 = (ii + 1) * step3;
                const corners = [
                    [i0 / (Nm - 1), j0 / (Nc - 1), P[j0][i0] / maxP * 0.5],
                    [i1 / (Nm - 1), j0 / (Nc - 1), P[j0][i1] / maxP * 0.5],
                    [i1 / (Nm - 1), j1 / (Nc - 1), P[j1][i1] / maxP * 0.5],
                    [i0 / (Nm - 1), j1 / (Nc - 1), P[j1][i0] / maxP * 0.5]
                ];
                const proj = corners.map(c => proj3(c[0], c[1], c[2]));
                const avgDepth = proj.reduce((s, p) => s + p.depth, 0) / 4;
                const avgZ = corners.reduce((s, c) => s + c[2], 0) / 4;
                quads3D.push({ proj, avgDepth, colorT: avgZ / 0.5 });
            }
        }
        quads3D.sort((a, b) => a.avgDepth - b.avgDepth);

        // ========== Canvas setup ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const cssW = 920, cssH = 430;
        canvas.width = cssW * dpr; canvas.height = cssH * dpr;
        canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
        ctx.scale(dpr, dpr);

        // Layout
        const L = { left: 50, top: 30, w: 300, h: 340 };   // left panel
        const R = { left: 470, top: 30, w: 300, h: 340 };   // right panel (heatmap)
        const CB = { left: 785, top: 30, w: 18, h: 340 };   // color bar
        const S3 = { left: 475, top: 240, w: 120, h: 120 }; // 3D inset

        // ========== Drawing ==========
        function draw() {
            const mi = parseInt(document.getElementById('mSlider').value);
            const ci = parseInt(document.getElementById('cSlider').value);
            const m = mArr[mi], c = cArr[ci];

            document.getElementById('mVal').textContent = m.toFixed(2);
            document.getElementById('cVal').textContent = c.toFixed(2);

            ctx.clearRect(0, 0, cssW, cssH);

            drawLeftPanel(m, c);
            drawRightPanel(m, c);
            drawColorBar();
            draw3DInset();
        }

        function drawLeftPanel(m, c) {
            const x0 = L.left, y0 = L.top, w = L.w, h = L.h;
            const xMin = 0, xMax = 1, yMin = 1, yMax = 7;
            function txl(x) { return x0 + (x - xMin) / (xMax - xMin) * w; }
            function tyl(y) { return y0 + (yMax - y) / (yMax - yMin) * h; }

            // Clip
            ctx.save();
            ctx.beginPath(); ctx.rect(x0, y0, w, h); ctx.clip();

            // True process (blue)
            ctx.strokeStyle = '#0000FF'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(txl(0), tyl(m0*0+c0)); ctx.lineTo(txl(1), tyl(m0*1+c0)); ctx.stroke();

            // Best fit (red)
            ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(txl(0), tyl(mf*0+cf)); ctx.lineTo(txl(1), tyl(mf*1+cf)); ctx.stroke();

            // Current model (green)
            ctx.strokeStyle = '#00AA00'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(txl(0), tyl(m*0+c)); ctx.lineTo(txl(1), tyl(m*1+c)); ctx.stroke();

            // Observations
            for (let k = 0; k < 10; k++) {
                ctx.fillStyle = 'white'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(txl(xo[k]), tyl(yo[k]), 5, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            }
            ctx.restore();

            // Axes
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(x0, y0, w, h);
            ctx.fillStyle = '#000'; ctx.font = '13px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let x = 0; x <= 1; x += 0.5) {
                ctx.beginPath(); ctx.moveTo(txl(x), y0 + h); ctx.lineTo(txl(x), y0 + h + 4); ctx.stroke();
                ctx.fillText(x.toFixed(1), txl(x), y0 + h + 6);
            }
            ctx.font = 'italic 14px Segoe UI';
            ctx.fillText('x', x0 + w / 2, y0 + h + 22);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            ctx.font = '13px Segoe UI';
            for (let y = 1; y <= 7; y += 2) {
                ctx.beginPath(); ctx.moveTo(x0 - 4, tyl(y)); ctx.lineTo(x0, tyl(y)); ctx.stroke();
                ctx.fillText(y.toString(), x0 - 6, tyl(y));
            }
            ctx.save(); ctx.translate(x0 - 32, y0 + h / 2); ctx.rotate(-Math.PI / 2);
            ctx.font = 'italic 14px Segoe UI'; ctx.textAlign = 'center';
            ctx.fillText('y', 0, 0); ctx.restore();

            // Legend
            const lx = x0 + 8, ly = y0 + 8;
            ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.fillRect(lx, ly, 130, 90); ctx.strokeRect(lx, ly, 130, 90);
            ctx.font = '12px Segoe UI'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            // obs
            ctx.fillStyle = 'white'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(lx+12, ly+14, 4, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#000'; ctx.fillText('observations', lx+25, ly+14);
            // best
            ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(lx+4, ly+34); ctx.lineTo(lx+20, ly+34); ctx.stroke();
            ctx.fillStyle = '#000'; ctx.fillText('best model', lx+25, ly+34);
            // true
            ctx.strokeStyle = '#0000FF'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(lx+4, ly+54); ctx.lineTo(lx+20, ly+54); ctx.stroke();
            ctx.fillStyle = '#000'; ctx.fillText('true process', lx+25, ly+54);
            // current
            ctx.strokeStyle = '#00AA00'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(lx+4, ly+74); ctx.lineTo(lx+20, ly+74); ctx.stroke();
            ctx.fillStyle = '#000'; ctx.fillText('\u03B8 = [m, c]', lx+25, ly+74);
        }

        function drawRightPanel(m, c) {
            const x0 = R.left, y0 = R.top, w = R.w, h = R.h;

            // Draw heatmap
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(hmCanvas, x0, y0, w, h);
            ctx.imageSmoothingEnabled = true;

            // Markers
            function txr(mv) { return x0 + (mv - mmin) / (mmax - mmin) * w; }
            function tyr(cv) { return y0 + (cmax - cv) / (cmax - cmin) * h; }

            // True theta (blue circle)
            ctx.fillStyle = '#0000FF'; ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(txr(m0), tyr(c0), 8, 0, 2*Math.PI); ctx.stroke(); ctx.fill();
            // Best theta (red circle)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath(); ctx.arc(txr(mf), tyr(cf), 8, 0, 2*Math.PI); ctx.stroke(); ctx.fill();
            // Current theta (green circle)
            ctx.fillStyle = '#00AA00';
            ctx.beginPath(); ctx.arc(txr(m), tyr(c), 8, 0, 2*Math.PI); ctx.stroke(); ctx.fill();

            // Border
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(x0, y0, w, h);

            // Axes
            ctx.fillStyle = '#000'; ctx.font = '13px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let mv = 1.5; mv <= 2.9; mv += 0.5) {
                ctx.beginPath(); ctx.moveTo(txr(mv), y0+h); ctx.lineTo(txr(mv), y0+h+4); ctx.stroke();
                ctx.fillText(mv.toFixed(1), txr(mv), y0+h+6);
            }
            ctx.font = 'italic 14px Segoe UI';
            ctx.fillText('m', x0+w/2, y0+h+22);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            ctx.font = '13px Segoe UI';
            for (let cv = 2.6; cv <= 3.5; cv += 0.2) {
                ctx.beginPath(); ctx.moveTo(x0-4, tyr(cv)); ctx.lineTo(x0, tyr(cv)); ctx.stroke();
                ctx.fillText(cv.toFixed(1), x0-6, tyr(cv));
            }
            ctx.save(); ctx.translate(x0-32, y0+h/2); ctx.rotate(-Math.PI/2);
            ctx.font = 'italic 14px Segoe UI'; ctx.textAlign = 'center';
            ctx.fillText('c', 0, 0); ctx.restore();

            // Legend
            const lx = x0+w-100, ly = y0+8;
            ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.fillRect(lx, ly, 92, 72); ctx.strokeRect(lx, ly, 92, 72);
            ctx.font = '12px Segoe UI'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            const markers = [
                { color: '#0000FF', label: '\u03B8\u2080' },
                { color: '#FF0000', label: '\u03B8\u0302\u2080' },
                { color: '#00AA00', label: '\u03B8' }
            ];
            for (let k = 0; k < 3; k++) {
                ctx.fillStyle = markers[k].color; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(lx+14, ly+14+k*22, 6, 0, 2*Math.PI); ctx.stroke(); ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillText(markers[k].label, lx+28, ly+14+k*22);
            }
        }

        function drawColorBar() {
            const x0 = CB.left, y0 = CB.top, w = CB.w, h = CB.h;
            for (let j = 0; j < h; j++) {
                const t = 1 - j / h;
                const [r, g, b] = jetRGB(t);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x0, y0 + j, w, 1);
            }
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(x0, y0, w, h);

            // Label
            ctx.save();
            ctx.translate(x0 + w + 18, y0 + h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'italic 13px Segoe UI';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.fillText('P(\u03B8)', 0, 0);
            ctx.restore();
        }

        function draw3DInset() {
            const x0 = S3.left, y0 = S3.top, w = S3.w, h = S3.h;
            const cx = x0 + w / 2, cy = y0 + h / 2;
            const sc = w * 0.7;

            // Background
            const [br, bg, bb] = jetRGB(0);
            ctx.fillStyle = `rgb(${br},${bg},${bb})`;
            ctx.fillRect(x0, y0, w, h);

            // Draw quads
            for (const q of quads3D) {
                const pts = q.proj.map(p => ({ x: cx + p.sx * sc, y: cy - p.sy * sc }));
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let k = 1; k < 4; k++) ctx.lineTo(pts[k].x, pts[k].y);
                ctx.closePath();
                const [r, g, b] = jetRGB(q.colorT);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 0.3;
                ctx.stroke();
            }

            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(x0, y0, w, h);
        }

        // ========== Events ==========
        document.getElementById('mSlider').addEventListener('input', draw);
        document.getElementById('cSlider').addEventListener('input', draw);
        draw();
    </script>
</body>
</html>
