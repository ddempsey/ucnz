<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncertainty - Structural Error</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { text-align: center; color: #333; }
        .explainer {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        .explainer p { margin: 1em 0; }
        .widget-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-group label { font-weight: 500; }
        .control-group input[type="range"] { width: 150px; }
        select { padding: 4px 8px; font-size: 14px; }
        .canvas-container { display: flex; justify-content: center; }
        canvas { border: 1px solid #ddd; background: white; max-width: 100%; }
        #loadMsg { text-align: center; font-style: italic; color: #888; margin-bottom: 10px; }
        .questions {
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            line-height: 1.8;
        }
        .questions p { margin: 0.8em 0; color: #555; }
    </style>
</head>
<body>
    <h1>Structural Error</h1>

    <div class="explainer">
        <p>
            Another group of scientists have developed a different model. They know without a
            doubt<sup><a href="https://i.kym-cdn.com/photos/images/original/001/153/173/152.jpg"
            style="color:#888;">1</a></sup> that the true process is logarithmic
            and is described by a relationship of the form: \(y_i = a\,\ln(x_i - x_0) + b\).
            Having three parameters instead of two, their model is clearly more
            sophisticated than the linear one (albeit, less correct).
        </p>
        <p>
            Undertaking a similar analysis of the data, they compute a best-fit model, construct
            the posterior parameter distribution, and sample from it to obtain a forecast of the
            future. This widget implements their analysis alongside the forecast from the first
            group, who used a linear model.
        </p>
        <p>
            How did the second group get it so wrong? They followed the same procedure as the
            first group: fitting a model to the data, exploring parameter space, and sampling from
            the posterior to construct a forecast. Indeed, the best-fit logarithmic model has a
            <em>smaller</em> objective function than the best-fit linear model, and on that basis
            we might prefer the former. The error occurred early on during <strong>model
            selection</strong> when the underlying physics were assumed to be logarithmic in
            nature &mdash; <strong>structural error</strong> was introduced during model
            development that had a deleterious effect on predictions.
        </p>
        <p style="font-size:0.8em; color:#666; margin-top:0.5em;">
            <sup>1</sup> "<em>It is very difficult to find a black cat in a dark room.
            Especially when there is no cat.</em>" &mdash;
            <a href="https://i.kym-cdn.com/photos/images/original/001/153/173/152.jpg"
            style="color:#888;">Proverb</a>.
        </p>
        <p><strong>Switch between alternative models and adjust \(x_f\).</strong></p>
    </div>

    <div class="widget-container">
        <div class="controls">
            <div class="control-group">
                <label><input type="checkbox" id="zoomCheck"> zoom</label>
            </div>
            <div class="control-group">
                <label>alternative model:</label>
                <select id="modelSelect">
                    <option value="power">power-law</option>
                    <option value="log" selected>logarithmic</option>
                    <option value="sin">sinusoidal</option>
                </select>
            </div>
            <div class="control-group">
                <label>\(x_f\):</label>
                <input type="range" id="xfSlider" min="20" max="50" step="5" value="30">
                <span id="xfVal">3.0</span>
            </div>
        </div>
        <div id="loadMsg">Computing posteriors... please wait.</div>
        <div class="canvas-container">
            <canvas id="canvas" width="850" height="430"></canvas>
        </div>
    </div>

    <div class="questions">
        <p>Switch between the models using the dropdown menu. Zoom in to see how each fits the data.</p>
        <p>Rank the four models (incl. linear) in terms of fit to the data.
           (The legend on the lefthand figures gives the objective function value \(S\).)</p>
        <p>If "ability to fit the data" was the only criterion to choose a model, which would you choose?</p>
        <p>Of the three competing models, which ones successfully "predict" the future at \(x_f = 3\)?</p>
        <p>Describe the magnitude of the prediction error for alternative models as \(x_f\) increases.</p>
        <p>What (real-world) actions could you take to help choose between competing models?</p>
    </div>

    <script>
        // ========== PRNG ==========
        function mulberry32(a) {
            return function() {
                a |= 0; a = a + 0x6D2B79F5 | 0;
                var t = Math.imul(a ^ a >>> 15, 1 | a);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }
        function randn(rng) {
            let u1; do { u1 = rng(); } while (u1 === 0);
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * rng());
        }

        // ========== Model functions ==========
        const m0 = 2, c0 = 3, variance = 0.1;
        function linear(x, p) { return p[0] * x + p[1]; }
        function powerlaw(x, p) { return p[0] + p[1] * Math.pow(Math.max(x, 1e-10), p[2]); }
        function logarithmic(x, p) { const v = x + p[2]; return v > 0 ? p[0] + p[1] * Math.log10(v) : NaN; }
        function sinusoid(x, p) { return p[0] + p[1] * Math.sin(p[2] * (x - 0.1)); }

        // ========== Observations (Python numpy, seed=13, m=2, c=3, var=0.1) ==========
        const xo = [0.090909090909091, 0.181818181818182, 0.272727272727273, 0.363636363636364, 0.454545454545455, 0.545454545454545, 0.636363636363636, 0.727272727272727, 0.818181818181818, 0.909090909090909];
        const yo = [2.956540474226668, 3.601998221658524, 3.531381436410830, 3.870148333813151, 4.334449417419804, 4.259249112090596, 4.699694175959493, 4.726884403467310, 5.103965123753951, 4.487604543546525];

        // Closed-form linear LSQ
        function linearLSQ(x, y) {
            const n = x.length; let sx=0,sy=0,sxx=0,sxy=0;
            for (let i=0;i<n;i++){sx+=x[i];sy+=y[i];sxx+=x[i]*x[i];sxy+=x[i]*y[i];}
            const d=n*sxx-sx*sx;
            return [(n*sxy-sx*sy)/d,(sy*sxx-sx*sxy)/d];
        }

        // ========== Gauss-Newton optimizer ==========
        function solveLinSys(A, b) {
            const n = b.length;
            const M = A.map((row, i) => [...row, b[i]]);
            for (let i = 0; i < n; i++) {
                let mx = i;
                for (let k = i+1; k < n; k++) if (Math.abs(M[k][i]) > Math.abs(M[mx][i])) mx = k;
                [M[i], M[mx]] = [M[mx], M[i]];
                if (Math.abs(M[i][i]) < 1e-20) return null;
                for (let k = i+1; k < n; k++) {
                    const f = M[k][i] / M[i][i];
                    for (let j = i; j <= n; j++) M[k][j] -= f * M[i][j];
                }
            }
            const x = new Array(n);
            for (let i = n-1; i >= 0; i--) {
                x[i] = M[i][n];
                for (let j = i+1; j < n; j++) x[i] -= M[i][j] * x[j];
                x[i] /= M[i][i];
            }
            return x;
        }

        function fitModel(f, p0) {
            let p = [...p0];
            const np = p.length, nd = xo.length;
            const h = 1e-7;
            for (let iter = 0; iter < 200; iter++) {
                const r = []; let hasNaN = false;
                for (let i = 0; i < nd; i++) { const v = yo[i] - f(xo[i], p); if (isNaN(v)) { hasNaN = true; break; } r.push(v); }
                if (hasNaN) break;
                const J = [];
                for (let i = 0; i < nd; i++) {
                    J[i] = [];
                    for (let j = 0; j < np; j++) {
                        const pp = [...p]; pp[j] += h;
                        const pm = [...p]; pm[j] -= h;
                        const fp = f(xo[i], pp), fm = f(xo[i], pm);
                        J[i][j] = (isNaN(fp) || isNaN(fm)) ? 0 : (fp - fm) / (2*h);
                    }
                }
                const JtJ = [], Jtr = [];
                for (let j = 0; j < np; j++) {
                    JtJ[j] = [];
                    Jtr[j] = 0;
                    for (let k = 0; k < np; k++) {
                        JtJ[j][k] = (j===k ? 1e-4 : 0);
                        for (let i = 0; i < nd; i++) JtJ[j][k] += J[i][j] * J[i][k];
                    }
                    for (let i = 0; i < nd; i++) Jtr[j] += J[i][j] * r[i];
                }
                const dp = solveLinSys(JtJ, Jtr);
                if (!dp) break;
                let maxDp = 0;
                for (let j = 0; j < np; j++) { p[j] += dp[j]; maxDp = Math.max(maxDp, Math.abs(dp[j])); }
                if (maxDp < 1e-12) break;
            }
            // Compute covariance
            const J = [];
            for (let i = 0; i < nd; i++) {
                J[i] = [];
                for (let j = 0; j < np; j++) {
                    const pp = [...p]; pp[j] += h;
                    const pm = [...p]; pm[j] -= h;
                    J[i][j] = (f(xo[i], pp) - f(xo[i], pm)) / (2*h);
                }
            }
            const sig2 = variance / 2;
            const JtJ = [];
            for (let j = 0; j < np; j++) { JtJ[j] = []; for (let k = 0; k < np; k++) { JtJ[j][k] = 0; for (let i = 0; i < nd; i++) JtJ[j][k] += J[i][j]*J[i][k]; }}
            // Invert JtJ * sig2
            const cov = invertMatrix(JtJ, sig2);
            return { mean: p, cov };
        }

        function invertMatrix(M, scale) {
            const n = M.length;
            const aug = M.map((row, i) => { const r = [...row]; for (let j = 0; j < n; j++) r.push(i===j?1:0); return r; });
            for (let i = 0; i < n; i++) {
                let mx = i;
                for (let k = i+1; k < n; k++) if (Math.abs(aug[k][i]) > Math.abs(aug[mx][i])) mx = k;
                [aug[i], aug[mx]] = [aug[mx], aug[i]];
                if (Math.abs(aug[i][i]) < 1e-20) return null;
                const div = aug[i][i];
                for (let j = 0; j < 2*n; j++) aug[i][j] /= div;
                for (let k = 0; k < n; k++) {
                    if (k === i) continue;
                    const f = aug[k][i];
                    for (let j = 0; j < 2*n; j++) aug[k][j] -= f * aug[i][j];
                }
            }
            const inv = [];
            for (let i = 0; i < n; i++) { inv[i] = []; for (let j = 0; j < n; j++) inv[i][j] = aug[i][n+j] * scale; }
            return inv;
        }

        // ========== Grid search + rejection sampling ==========
        function gridSearch(f, bestP, Ngrid) {
            const np = bestP.length;
            const ranges = bestP.map(pi => {
                const lo = pi / 3, hi = pi * 3;
                const arr = [];
                for (let i = 0; i < Ngrid; i++) arr.push(lo + i * (hi - lo) / (Ngrid - 1));
                return arr;
            });
            const dps = ranges.map(r => Math.abs(r[1] - r[0]));

            // Total grid points
            let totalPts = 1;
            for (let d = 0; d < np; d++) totalPts *= Ngrid;

            const flatP = new Float64Array(totalPts);
            const flatPVS = [];
            for (let d = 0; d < np; d++) flatPVS.push(new Float64Array(totalPts));

            for (let idx = 0; idx < totalPts; idx++) {
                let rem = idx;
                const theta = [];
                for (let d = np - 1; d >= 0; d--) {
                    const gi = rem % Ngrid;
                    rem = Math.floor(rem / Ngrid);
                    theta[d] = ranges[d][gi];
                    flatPVS[d][idx] = ranges[d][gi];
                }
                let S = 0; let valid = true;
                for (let k = 0; k < 10; k++) {
                    const v = yo[k] - f(xo[k], theta);
                    if (isNaN(v)) { valid = false; break; }
                    S += v * v / variance;
                }
                flatP[idx] = valid ? Math.exp(-S / 2) : 0;
            }

            // Normalize
            let sumP = 0;
            for (let i = 0; i < totalPts; i++) sumP += flatP[i];
            const prodDp = dps.reduce((a, b) => a * b, 1);
            sumP *= prodDp;
            for (let i = 0; i < totalPts; i++) flatP[i] /= sumP;

            return { flatP, flatPVS, dps, totalPts };
        }

        function rejectionSample(grid, N, rng) {
            const { flatP, flatPVS, dps, totalPts } = grid;
            const np = flatPVS.length;
            let pmax = 0;
            const validIdx = [];
            for (let i = 0; i < totalPts; i++) pmax = Math.max(pmax, flatP[i]);
            for (let i = 0; i < totalPts; i++) if (flatP[i] > pmax / 1000) validIdx.push(i);
            const nv = validIdx.length;
            const samples = [];
            let attempts = 0;
            while (samples.length < N && attempts < N * 10000) {
                attempts++;
                const vi = validIdx[Math.floor(rng() * nv)];
                if (flatP[vi] > rng() * pmax) {
                    const s = [];
                    for (let d = 0; d < np; d++) s.push(flatPVS[d][vi] + dps[d] * (rng() - 0.5));
                    samples.push(s);
                }
            }
            return samples;
        }

        // ========== Pre-computation (async to not block UI) ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const cssW = 850, cssH = 430;
        canvas.width = cssW * dpr; canvas.height = cssH * dpr;
        canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
        ctx.scale(dpr, dpr);

        const PL = { x: 55, y: 30, w: 350, h: 340 };
        const PR = { x: 480, y: 30, w: 310, h: 340 };

        let modelData = {};

        function computeAll() {
            // Linear model
            const linP = linearLSQ(xo, yo);
            const linFit = fitModel(linear, linP);
            modelData.linear = linFit;

            // Alternative models
            const models = {
                power: { f: powerlaw, p0: [1, 1, 1], col: '#CC00CC' },
                log: { f: logarithmic, p0: [5, 2.5, 0.1], col: '#FF0000' },
                sin: { f: sinusoid, p0: [3, 2, 3], col: '#00AA00' }
            };

            const Ngrid = 25;
            for (const [name, m] of Object.entries(models)) {
                const fit = fitModel(m.f, m.p0);
                const grid = gridSearch(m.f, fit.mean, Ngrid);
                modelData[name] = { fit, grid, f: m.f, col: m.col };
            }

            document.getElementById('loadMsg').style.display = 'none';
            draw();
        }

        function draw() {
            if (!modelData.linear) return;
            const zoom = document.getElementById('zoomCheck').checked;
            const option = document.getElementById('modelSelect').value;
            const xf = parseInt(document.getElementById('xfSlider').value) / 10;
            document.getElementById('xfVal').textContent = xf.toFixed(1);

            const md = modelData[option];
            const col = md.col;
            const f2 = md.f;
            const N = 256;

            // Sample linear (MVN)
            const rng1 = mulberry32(13);
            const lm = modelData.linear.mean;
            const lc = modelData.linear.cov;
            const L11 = Math.sqrt(lc[0][0]), L21 = lc[1][0] / L11, L22 = Math.sqrt(lc[1][1] - L21*L21);
            const linSamples = [];
            for (let i = 0; i < N; i++) {
                const z1 = randn(rng1), z2 = randn(rng1);
                linSamples.push([lm[0] + L11*z1, lm[1] + L21*z1 + L22*z2]);
            }

            // Sample alternative (rejection)
            const rng2 = mulberry32(42);
            const altSamples = rejectionSample(md.grid, N, rng2);

            ctx.clearRect(0, 0, cssW, cssH);

            // ===== Left panel =====
            const xMinL = zoom ? 0 : xo[0], xMaxL = zoom ? 1 : 5.5;
            const yMinL = zoom ? 1 : 0, yMaxL = zoom ? 7 : 15;
            function tx1(x) { return PL.x + (x - xMinL) / (xMaxL - xMinL) * PL.w; }
            function ty1(y) { return PL.y + (yMaxL - y) / (yMaxL - yMinL) * PL.h; }

            ctx.save();
            ctx.beginPath(); ctx.rect(PL.x, PL.y, PL.w, PL.h); ctx.clip();

            const alpha = Math.min(0.5, 10 / N);
            const yfsLin = [], yfsAlt = [];
            const xLine = []; for (let i = 0; i <= 200; i++) xLine.push(0.005 + i * (5.5 - 0.005) / 200);

            // Linear ensemble (black)
            for (const s of linSamples) {
                ctx.strokeStyle = `rgba(0,0,0,${alpha})`; ctx.lineWidth = 0.5;
                ctx.beginPath();
                for (let i = 0; i < xLine.length; i++) {
                    const v = linear(xLine[i], s);
                    if (i === 0) ctx.moveTo(tx1(xLine[i]), ty1(v)); else ctx.lineTo(tx1(xLine[i]), ty1(v));
                }
                ctx.stroke();
                yfsLin.push(linear(xf, s));
            }

            // Alt ensemble
            for (const s of altSamples) {
                ctx.strokeStyle = col.replace(')', `,${alpha})`).replace('rgb', 'rgba').replace('#', '');
                // Use hex-to-rgba
                const r = parseInt(col.slice(1,3),16), g = parseInt(col.slice(3,5),16), b = parseInt(col.slice(5,7),16);
                ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                let valid = true;
                for (let i = 0; i < xLine.length; i++) {
                    const v = f2(xLine[i], s);
                    if (isNaN(v)) { valid = false; break; }
                    if (i === 0) ctx.moveTo(tx1(xLine[i]), ty1(v)); else ctx.lineTo(tx1(xLine[i]), ty1(v));
                }
                if (valid) ctx.stroke();
                const vf = f2(xf, s);
                if (!isNaN(vf)) yfsAlt.push(vf);
            }

            // True process (blue)
            ctx.strokeStyle = '#0000FF'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(tx1(xMinL), ty1(m0*xMinL+c0)); ctx.lineTo(tx1(xMaxL), ty1(m0*xMaxL+c0)); ctx.stroke();

            // Best linear (black thick)
            const Slin = xo.reduce((s, xi, i) => s + (yo[i] - linear(xi, lm)) ** 2 / variance, 0);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(tx1(xMinL), ty1(linear(xMinL, lm))); ctx.lineTo(tx1(xMaxL), ty1(linear(xMaxL, lm))); ctx.stroke();

            // Best alt (colored thick)
            const Salt = xo.reduce((s, xi, i) => { const v = f2(xi, md.fit.mean); return s + (isNaN(v) ? 0 : (yo[i] - v) ** 2 / variance); }, 0);
            ctx.strokeStyle = col; ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < xLine.length; i++) {
                const v = f2(xLine[i], md.fit.mean);
                if (isNaN(v)) continue;
                if (i === 0 || isNaN(f2(xLine[i-1], md.fit.mean))) ctx.moveTo(tx1(xLine[i]), ty1(v));
                else ctx.lineTo(tx1(xLine[i]), ty1(v));
            }
            ctx.stroke();

            // xf line
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
            ctx.beginPath(); ctx.moveTo(tx1(xf), PL.y); ctx.lineTo(tx1(xf), PL.y+PL.h); ctx.stroke();
            ctx.setLineDash([]);

            // Observations
            for (let k = 0; k < 10; k++) {
                ctx.fillStyle = 'white'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(tx1(xo[k]), ty1(yo[k]), 5, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
            }
            ctx.restore();

            // Left axes
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(PL.x, PL.y, PL.w, PL.h);
            ctx.fillStyle = '#000'; ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const xStep = zoom ? 0.2 : 1;
            for (let x = Math.ceil(xMinL/xStep)*xStep; x <= xMaxL+0.001; x += xStep) {
                ctx.beginPath(); ctx.moveTo(tx1(x), PL.y+PL.h); ctx.lineTo(tx1(x), PL.y+PL.h+4); ctx.stroke();
                ctx.fillText(x%1===0||zoom?x.toFixed(zoom?1:0):x.toFixed(1), tx1(x), PL.y+PL.h+6);
            }
            ctx.font = 'italic 14px Segoe UI'; ctx.fillText('x', PL.x+PL.w/2, PL.y+PL.h+22);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; ctx.font = '12px Segoe UI';
            const yStep = zoom ? 1 : 5;
            for (let y = Math.ceil(yMinL/yStep)*yStep; y <= yMaxL; y += yStep) {
                ctx.beginPath(); ctx.moveTo(PL.x-4, ty1(y)); ctx.lineTo(PL.x, ty1(y)); ctx.stroke();
                ctx.fillText(y.toString(), PL.x-6, ty1(y));
            }
            ctx.save(); ctx.translate(PL.x-32, PL.y+PL.h/2); ctx.rotate(-Math.PI/2);
            ctx.font = 'italic 14px Segoe UI'; ctx.textAlign = 'center'; ctx.fillText('y', 0, 0); ctx.restore();

            // Left legend
            const lx = PL.x+6, ly = PL.y+6;
            const names = { power: 'power', log: 'log', sin: 'sin' };
            ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            ctx.fillRect(lx, ly, 200, 82); ctx.strokeRect(lx, ly, 200, 82);
            ctx.font = '11px Segoe UI'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            const legendItems = [
                { c: 'white', sc: '#000', t: 'circle', label: 'obs.' },
                { c: '#0000FF', t: 'line', label: 'true process' },
                { c: '#000', t: 'line', label: 'best linear (S=' + Slin.toFixed(1) + ')' },
                { c: col, t: 'line', label: 'best ' + names[option] + ' (S=' + Salt.toFixed(1) + ')' }
            ];
            for (let i = 0; i < legendItems.length; i++) {
                const it = legendItems[i], iy = ly + 12 + i * 16;
                if (it.t === 'circle') {
                    ctx.fillStyle = it.c; ctx.strokeStyle = it.sc; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(lx+10, iy, 3, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
                } else {
                    ctx.strokeStyle = it.c; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(lx+3, iy); ctx.lineTo(lx+17, iy); ctx.stroke();
                }
                ctx.fillStyle = '#000'; ctx.fillText(it.label, lx+22, iy);
            }

            // ===== Right panel: forecast histograms =====
            const hMin = 0, hMax = 20, pyMin = 0, pyMax = 1;
            function tx2(v) { return PR.x + (v - hMin) / (hMax - hMin) * PR.w; }
            function ty2(v) { return PR.y + (pyMax - v) / (pyMax - pyMin) * PR.h; }

            ctx.save();
            ctx.beginPath(); ctx.rect(PR.x, PR.y, PR.w, PR.h); ctx.clip();

            const bins = []; for (let i = 0; i <= 60; i++) bins.push(i * 20 / 60);

            // Linear histogram (black)
            drawHistogram(yfsLin, bins, 'rgba(0,0,0,0.5)', '#000', tx2, ty2, PR);
            // Alt histogram (colored)
            const cr = parseInt(col.slice(1,3),16), cg = parseInt(col.slice(3,5),16), cb = parseInt(col.slice(5,7),16);
            drawHistogram(yfsAlt, bins, `rgba(${cr},${cg},${cb},0.5)`, col, tx2, ty2, PR);

            if (N > 10) {
                // True process
                const y0 = m0 * xf + c0;
                ctx.strokeStyle = '#0000FF'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(tx2(y0), PR.y); ctx.lineTo(tx2(y0), PR.y+PR.h); ctx.stroke();

                // 90% intervals
                function drawInterval(yfs, color) {
                    if (yfs.length < 5) return;
                    const sorted = [...yfs].sort((a,b) => a-b);
                    const p5 = sorted[Math.floor(0.05 * sorted.length)];
                    const p95 = sorted[Math.floor(0.95 * sorted.length)];
                    ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.setLineDash([6,4]);
                    ctx.beginPath(); ctx.moveTo(tx2(p5), PR.y); ctx.lineTo(tx2(p5), PR.y+PR.h); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(tx2(p95), PR.y); ctx.lineTo(tx2(p95), PR.y+PR.h); ctx.stroke();
                    ctx.setLineDash([]);
                }
                drawInterval(yfsLin, '#000');
                drawInterval(yfsAlt, col);
            }

            ctx.restore();

            ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.strokeRect(PR.x, PR.y, PR.w, PR.h);
            ctx.fillStyle = '#000'; ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let v = 0; v <= 20; v += 5) {
                ctx.beginPath(); ctx.moveTo(tx2(v), PR.y+PR.h); ctx.lineTo(tx2(v), PR.y+PR.h+4); ctx.stroke();
                ctx.fillText(v.toString(), tx2(v), PR.y+PR.h+6);
            }
            ctx.font = 'italic 14px Segoe UI'; ctx.fillText('y_f', PR.x+PR.w/2, PR.y+PR.h+22);
            ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; ctx.font = '12px Segoe UI';
            for (let v = 0; v <= 1; v += 0.5) {
                ctx.beginPath(); ctx.moveTo(PR.x-4, ty2(v)); ctx.lineTo(PR.x, ty2(v)); ctx.stroke();
                ctx.fillText(v.toFixed(1), PR.x-6, ty2(v));
            }
            ctx.save(); ctx.translate(PR.x-28, PR.y+PR.h/2); ctx.rotate(-Math.PI/2);
            ctx.font = 'italic 14px Segoe UI'; ctx.textAlign = 'center'; ctx.fillText('P(y_f)', 0, 0); ctx.restore();

            // Right legend
            if (N > 10) {
                const lxR = PR.x+PR.w-130, lyR = PR.y+6;
                ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
                ctx.fillRect(lxR, lyR, 122, 68); ctx.strokeRect(lxR, lyR, 122, 68);
                ctx.font = '11px Segoe UI'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                const rItems = [
                    ['#0000FF','-','true process'],
                    ['#000','--','90% linear'],
                    [col,'--','90% '+names[option]]
                ];
                for (let i = 0; i < rItems.length; i++) {
                    const iy = lyR + 12 + i * 18;
                    ctx.strokeStyle = rItems[i][0]; ctx.lineWidth = 1.5;
                    if (rItems[i][1] === '--') ctx.setLineDash([4,3]);
                    ctx.beginPath(); ctx.moveTo(lxR+4, iy); ctx.lineTo(lxR+20, iy); ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#000'; ctx.fillText(rItems[i][2], lxR+24, iy);
                }
            }
        }

        function drawHistogram(data, bins, fillCol, strokeCol, tx, ty, panel) {
            if (data.length === 0) return;
            const nBins = bins.length - 1;
            const counts = new Array(nBins).fill(0);
            for (const v of data) {
                for (let i = 0; i < nBins; i++) {
                    if (v >= bins[i] && v < bins[i+1]) { counts[i]++; break; }
                }
            }
            const binW = bins[1] - bins[0];
            const total = data.length * binW;
            ctx.fillStyle = fillCol;
            ctx.strokeStyle = strokeCol;
            ctx.lineWidth = 0.5;
            for (let i = 0; i < nBins; i++) {
                const h = counts[i] / total;
                if (h > 0) {
                    const bx = tx(bins[i]), bw = tx(bins[i+1]) - tx(bins[i]);
                    ctx.fillRect(bx, ty(h), bw, ty(0) - ty(h));
                    ctx.strokeRect(bx, ty(h), bw, ty(0) - ty(h));
                }
            }
        }

        document.getElementById('zoomCheck').addEventListener('change', draw);
        document.getElementById('modelSelect').addEventListener('change', draw);
        document.getElementById('xfSlider').addEventListener('input', draw);

        // Defer computation to allow page render
        setTimeout(computeAll, 50);
    </script>
</body>
</html>
